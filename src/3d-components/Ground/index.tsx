/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useTexture } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { useMemo, useRef } from "react";
import { MirrorMaterial } from "./MirrorMaterial";
import { MirrorTexture } from "./MirrorTexture";
import * as THREE from "three";
import { degToRad } from "three/src/math/MathUtils.js";

interface GroundProps {
  dropsRef?: React.MutableRefObject<THREE.Group>;
  splashRef?: React.MutableRefObject<THREE.Group>;
  exceptRef?: React.MutableRefObject<THREE.Group>;
}

export function Ground({dropsRef, splashRef, exceptRef}: GroundProps) {
  const [colorMap, roughnessMap, normalMap, dispMap] = useTexture([
    'textures/aerial_rocks_01_1k/aerial_rocks_01_diff_1k.jpg',
    'textures/aerial_rocks_01_1k/aerial_rocks_01_rough_1k.png', 
    'textures/aerial_rocks_01_1k/aerial_rocks_01_nor_gl_1k.png',
    'textures/aerial_rocks_01_1k/aerial_rocks_01_disp_1k.png'])

  const camera = useThree((state) => state.camera);
  const size = useThree((state) => state.size);

  const mirrorTexture = useMemo(
    () => new MirrorTexture(camera, size),
    [camera]
  );

  const mirrorRef = useRef<THREE.Mesh>(null!);

  useFrame(({ gl, scene, camera }) => {
    if (dropsRef && dropsRef.current) dropsRef.current.visible = false;
    if (splashRef && splashRef.current) splashRef.current.visible = false;
    if (exceptRef && exceptRef.current) exceptRef.current.visible = false;
    mirrorRef.current.visible = false;
    mirrorTexture.render(gl, scene, camera);
    mirrorRef.current.visible = true;
    if (dropsRef && dropsRef.current) dropsRef.current.visible = true;
    if (splashRef && splashRef.current) splashRef.current.visible = true;
    if (exceptRef && exceptRef.current) exceptRef.current.visible = true;
  });

  const rockMaterial = useMemo(() => {
  return new THREE.MeshStandardMaterial({
    map: colorMap,
    roughnessMap,
    normalMap,
    displacementMap: dispMap,
    displacementScale: 0.2,
    displacementBias: -0.06,
    metalness: 0,
    roughness: 0.2,
  })
}, [colorMap, roughnessMap, normalMap, dispMap])

  return (
    <group dispose={null}>
      <mesh
        ref={mirrorRef}
        castShadow
        receiveShadow
        renderOrder={1}
        rotation={[degToRad(-90), 0, 0]}
      >
        <planeGeometry args={[7, 7, 64, 64]} />
        <MirrorMaterial
          baseMaterial={rockMaterial}
          renderTexture={mirrorTexture}
        />
      </mesh>
    </group>
  );
}
